# Generated from RosMessageParser.g4 by ANTLR 4.7.2
# encoding: utf-8
from __future__ import print_function
from antlr4 import *
from io import StringIO
import sys


def serializedATN():
    with StringIO() as buf:
        buf.write(u"\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3")
        buf.write(u"/\u00c3\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t")
        buf.write(u"\7\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r")
        buf.write(u"\4\16\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4")
        buf.write(u"\23\t\23\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30")
        buf.write(u"\t\30\4\31\t\31\4\32\t\32\4\33\t\33\3\2\3\2\3\2\5\2:")
        buf.write(u"\n\2\3\3\3\3\3\3\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\5\3\5")
        buf.write(u"\3\5\3\5\3\5\3\6\3\6\7\6M\n\6\f\6\16\6P\13\6\3\6\3\6")
        buf.write(u"\3\7\3\7\3\7\3\7\3\b\3\b\3\b\7\b[\n\b\f\b\16\b^\13\b")
        buf.write(u"\3\t\3\t\5\tb\n\t\3\t\3\t\3\n\3\n\3\n\3\n\3\n\3\n\3\n")
        buf.write(u"\3\n\3\n\3\n\5\np\n\n\3\n\3\n\3\n\3\n\3\n\5\nw\n\n\3")
        buf.write(u"\n\3\n\3\n\3\n\3\n\5\n~\n\n\3\13\3\13\3\13\5\13\u0083")
        buf.write(u"\n\13\3\f\3\f\3\r\3\r\3\r\3\r\3\r\3\r\5\r\u008d\n\r\3")
        buf.write(u"\16\3\16\3\16\3\16\5\16\u0093\n\16\3\17\3\17\5\17\u0097")
        buf.write(u"\n\17\3\20\3\20\3\20\3\20\3\21\3\21\3\21\3\21\3\21\3")
        buf.write(u"\21\3\21\3\21\3\21\3\21\5\21\u00a7\n\21\3\22\3\22\3\23")
        buf.write(u"\3\23\3\24\3\24\3\25\3\25\3\26\3\26\3\27\3\27\3\30\5")
        buf.write(u"\30\u00b6\n\30\3\30\3\30\3\31\5\31\u00bb\n\31\3\31\3")
        buf.write(u"\31\3\32\3\32\3\33\3\33\3\33\2\2\34\2\4\6\b\n\f\16\20")
        buf.write(u"\22\24\26\30\32\34\36 \"$&(*,.\60\62\64\2\13\4\2\31\31")
        buf.write(u"))\5\2\3\22\35\37$$\4\2\24\24%%\4\2\25\25&&\3\2\4\r\3")
        buf.write(u"\2\16\17\3\2\21\22\3\2\27\30\3\2\35\36\2\u00bf\29\3\2")
        buf.write(u"\2\2\4;\3\2\2\2\6>\3\2\2\2\bE\3\2\2\2\nJ\3\2\2\2\fS\3")
        buf.write(u"\2\2\2\16\\\3\2\2\2\20a\3\2\2\2\22}\3\2\2\2\24\u0082")
        buf.write(u"\3\2\2\2\26\u0084\3\2\2\2\30\u008c\3\2\2\2\32\u0092\3")
        buf.write(u"\2\2\2\34\u0096\3\2\2\2\36\u0098\3\2\2\2 \u00a6\3\2\2")
        buf.write(u"\2\"\u00a8\3\2\2\2$\u00aa\3\2\2\2&\u00ac\3\2\2\2(\u00ae")
        buf.write(u"\3\2\2\2*\u00b0\3\2\2\2,\u00b2\3\2\2\2.\u00b5\3\2\2\2")
        buf.write(u"\60\u00ba\3\2\2\2\62\u00be\3\2\2\2\64\u00c0\3\2\2\2\66")
        buf.write(u":\5\4\3\2\67:\5\6\4\28:\5\b\5\29\66\3\2\2\29\67\3\2\2")
        buf.write(u"\298\3\2\2\2:\3\3\2\2\2;<\5\16\b\2<=\7\2\2\3=\5\3\2\2")
        buf.write(u"\2>?\5\16\b\2?@\7\32\2\2@A\5\16\b\2AB\7\32\2\2BC\5\16")
        buf.write(u"\b\2CD\7\2\2\3D\7\3\2\2\2EF\5\16\b\2FG\7\32\2\2GH\5\16")
        buf.write(u"\b\2HI\7\2\2\3I\t\3\2\2\2JN\5\16\b\2KM\5\f\7\2LK\3\2")
        buf.write(u"\2\2MP\3\2\2\2NL\3\2\2\2NO\3\2\2\2OQ\3\2\2\2PN\3\2\2")
        buf.write(u"\2QR\7\2\2\3R\13\3\2\2\2ST\7 \2\2TU\5\32\16\2UV\5\16")
        buf.write(u"\b\2V\r\3\2\2\2W[\5\20\t\2X[\5\22\n\2Y[\5\24\13\2ZW\3")
        buf.write(u"\2\2\2ZX\3\2\2\2ZY\3\2\2\2[^\3\2\2\2\\Z\3\2\2\2\\]\3")
        buf.write(u"\2\2\2]\17\3\2\2\2^\\\3\2\2\2_b\5\30\r\2`b\5\34\17\2")
        buf.write(u"a_\3\2\2\2a`\3\2\2\2bc\3\2\2\2cd\5\26\f\2d\21\3\2\2\2")
        buf.write(u"ef\5\"\22\2fg\5\26\f\2gh\7\26\2\2hi\5.\30\2i~\3\2\2\2")
        buf.write(u"jk\5$\23\2kl\5\26\f\2lo\7\26\2\2mp\5.\30\2np\5\60\31")
        buf.write(u"\2om\3\2\2\2on\3\2\2\2p~\3\2\2\2qr\5*\26\2rs\5\26\f\2")
        buf.write(u"sv\7\26\2\2tw\5\62\32\2uw\5.\30\2vt\3\2\2\2vu\3\2\2\2")
        buf.write(u"w~\3\2\2\2xy\5(\25\2yz\5\26\f\2z{\7(\2\2{|\5\64\33\2")
        buf.write(u"|~\3\2\2\2}e\3\2\2\2}j\3\2\2\2}q\3\2\2\2}x\3\2\2\2~\23")
        buf.write(u"\3\2\2\2\177\u0080\t\2\2\2\u0080\u0083\7.\2\2\u0081\u0083")
        buf.write(u"\t\2\2\2\u0082\177\3\2\2\2\u0082\u0081\3\2\2\2\u0083")
        buf.write(u"\25\3\2\2\2\u0084\u0085\t\3\2\2\u0085\27\3\2\2\2\u0086")
        buf.write(u"\u008d\5\"\22\2\u0087\u008d\5$\23\2\u0088\u008d\5&\24")
        buf.write(u"\2\u0089\u008d\5*\26\2\u008a\u008d\5(\25\2\u008b\u008d")
        buf.write(u"\5\32\16\2\u008c\u0086\3\2\2\2\u008c\u0087\3\2\2\2\u008c")
        buf.write(u"\u0088\3\2\2\2\u008c\u0089\3\2\2\2\u008c\u008a\3\2\2")
        buf.write(u"\2\u008c\u008b\3\2\2\2\u008d\31\3\2\2\2\u008e\u0093\7")
        buf.write(u"\37\2\2\u008f\u0090\7\37\2\2\u0090\u0091\7\23\2\2\u0091")
        buf.write(u"\u0093\7\37\2\2\u0092\u008e\3\2\2\2\u0092\u008f\3\2\2")
        buf.write(u"\2\u0093\33\3\2\2\2\u0094\u0097\5\36\20\2\u0095\u0097")
        buf.write(u"\5 \21\2\u0096\u0094\3\2\2\2\u0096\u0095\3\2\2\2\u0097")
        buf.write(u"\35\3\2\2\2\u0098\u0099\5\30\r\2\u0099\u009a\t\4\2\2")
        buf.write(u"\u009a\u009b\t\5\2\2\u009b\37\3\2\2\2\u009c\u009d\5\30")
        buf.write(u"\r\2\u009d\u009e\7\24\2\2\u009e\u009f\7\33\2\2\u009f")
        buf.write(u"\u00a0\7\25\2\2\u00a0\u00a7\3\2\2\2\u00a1\u00a2\5\30")
        buf.write(u"\r\2\u00a2\u00a3\7%\2\2\u00a3\u00a4\7\'\2\2\u00a4\u00a5")
        buf.write(u"\7&\2\2\u00a5\u00a7\3\2\2\2\u00a6\u009c\3\2\2\2\u00a6")
        buf.write(u"\u00a1\3\2\2\2\u00a7!\3\2\2\2\u00a8\u00a9\t\6\2\2\u00a9")
        buf.write(u"#\3\2\2\2\u00aa\u00ab\t\7\2\2\u00ab%\3\2\2\2\u00ac\u00ad")
        buf.write(u"\t\b\2\2\u00ad\'\3\2\2\2\u00ae\u00af\7\20\2\2\u00af)")
        buf.write(u"\3\2\2\2\u00b0\u00b1\7\3\2\2\u00b1+\3\2\2\2\u00b2\u00b3")
        buf.write(u"\t\t\2\2\u00b3-\3\2\2\2\u00b4\u00b6\5,\27\2\u00b5\u00b4")
        buf.write(u"\3\2\2\2\u00b5\u00b6\3\2\2\2\u00b6\u00b7\3\2\2\2\u00b7")
        buf.write(u"\u00b8\7\33\2\2\u00b8/\3\2\2\2\u00b9\u00bb\5,\27\2\u00ba")
        buf.write(u"\u00b9\3\2\2\2\u00ba\u00bb\3\2\2\2\u00bb\u00bc\3\2\2")
        buf.write(u"\2\u00bc\u00bd\7\34\2\2\u00bd\61\3\2\2\2\u00be\u00bf")
        buf.write(u"\t\n\2\2\u00bf\63\3\2\2\2\u00c0\u00c1\7,\2\2\u00c1\65")
        buf.write(u"\3\2\2\2\219NZ\\aov}\u0082\u008c\u0092\u0096\u00a6\u00b5")
        buf.write(u"\u00ba")
        return buf.getvalue()


class RosMessageParser ( Parser ):

    grammarFileName = "RosMessageParser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ u"<INVALID>", u"'bool'", u"'int8'", u"'uint8'", u"'byte'", 
                     u"'char'", u"'int16'", u"'uint16'", u"'int32'", u"'uint32'", 
                     u"'int64'", u"'uint64'", u"'float32'", u"'float64'", 
                     u"'string'", u"'time'", u"'duration'", u"'/'", u"<INVALID>", 
                     u"<INVALID>", u"<INVALID>", u"'+'", u"'-'", u"<INVALID>", 
                     u"'---'", u"<INVALID>", u"<INVALID>", u"'True'", u"'False'" ]

    symbolicNames = [ u"<INVALID>", u"BOOL", u"INT8", u"UINT8", u"BYTE", 
                      u"CHAR", u"INT16", u"UINT16", u"INT32", u"UINT32", 
                      u"INT64", u"UINT64", u"FLOAT32", u"FLOAT64", u"STRING", 
                      u"TIME", u"DURATION", u"SLASH", u"OPEN_BRACKET", u"CLOSE_BRACKET", 
                      u"ASSIGNMENT", u"PLUS", u"MINUS", u"HASH", u"MESSAGE_SEPARATOR", 
                      u"INTEGER_LITERAL", u"REAL_LITERAL", u"TRUE", u"FALSE", 
                      u"IDENTIFIER", u"ROSBAG_MESSAGE_SEPARATOR", u"WHITESPACES", 
                      u"NEWLINES", u"NEWLINE", u"STRING_IDENTIFIER", u"STRING_OPEN_BRACKET", 
                      u"STRING_CLOSE_BRACKET", u"STRING_INTEGER_LITERAL", 
                      u"STRING_ASSIGNMENT", u"STRING_HASH", u"STRING_WHITESPACES", 
                      u"STRING_NEWLINE", u"STRING_VALUE", u"STRIN_ASSIGNMENT_NEWLINE", 
                      u"COMMENT", u"COMMENT_NEWLINE" ]

    RULE_ros_file_input = 0
    RULE_ros_message_input = 1
    RULE_ros_action_input = 2
    RULE_ros_service_input = 3
    RULE_rosbag_input = 4
    RULE_rosbag_nested_message = 5
    RULE_ros_message = 6
    RULE_field_declaration = 7
    RULE_constant_declaration = 8
    RULE_comment = 9
    RULE_identifier = 10
    RULE_dtype = 11
    RULE_ros_type = 12
    RULE_array_type = 13
    RULE_variable_array_type = 14
    RULE_fixed_array_type = 15
    RULE_integral_type = 16
    RULE_floating_point_type = 17
    RULE_temportal_type = 18
    RULE_string_type = 19
    RULE_boolean_type = 20
    RULE_sign = 21
    RULE_integral_value = 22
    RULE_floating_point_value = 23
    RULE_bool_value = 24
    RULE_string_value = 25

    ruleNames =  [ u"ros_file_input", u"ros_message_input", u"ros_action_input", 
                   u"ros_service_input", u"rosbag_input", u"rosbag_nested_message", 
                   u"ros_message", u"field_declaration", u"constant_declaration", 
                   u"comment", u"identifier", u"dtype", u"ros_type", u"array_type", 
                   u"variable_array_type", u"fixed_array_type", u"integral_type", 
                   u"floating_point_type", u"temportal_type", u"string_type", 
                   u"boolean_type", u"sign", u"integral_value", u"floating_point_value", 
                   u"bool_value", u"string_value" ]

    EOF = Token.EOF
    BOOL=1
    INT8=2
    UINT8=3
    BYTE=4
    CHAR=5
    INT16=6
    UINT16=7
    INT32=8
    UINT32=9
    INT64=10
    UINT64=11
    FLOAT32=12
    FLOAT64=13
    STRING=14
    TIME=15
    DURATION=16
    SLASH=17
    OPEN_BRACKET=18
    CLOSE_BRACKET=19
    ASSIGNMENT=20
    PLUS=21
    MINUS=22
    HASH=23
    MESSAGE_SEPARATOR=24
    INTEGER_LITERAL=25
    REAL_LITERAL=26
    TRUE=27
    FALSE=28
    IDENTIFIER=29
    ROSBAG_MESSAGE_SEPARATOR=30
    WHITESPACES=31
    NEWLINES=32
    NEWLINE=33
    STRING_IDENTIFIER=34
    STRING_OPEN_BRACKET=35
    STRING_CLOSE_BRACKET=36
    STRING_INTEGER_LITERAL=37
    STRING_ASSIGNMENT=38
    STRING_HASH=39
    STRING_WHITESPACES=40
    STRING_NEWLINE=41
    STRING_VALUE=42
    STRIN_ASSIGNMENT_NEWLINE=43
    COMMENT=44
    COMMENT_NEWLINE=45

    def __init__(self, input, output=sys.stdout):
        super(RosMessageParser, self).__init__(input, output=output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class Ros_file_inputContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(RosMessageParser.Ros_file_inputContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ros_message_input(self):
            return self.getTypedRuleContext(RosMessageParser.Ros_message_inputContext,0)


        def ros_action_input(self):
            return self.getTypedRuleContext(RosMessageParser.Ros_action_inputContext,0)


        def ros_service_input(self):
            return self.getTypedRuleContext(RosMessageParser.Ros_service_inputContext,0)


        def getRuleIndex(self):
            return RosMessageParser.RULE_ros_file_input

        def enterRule(self, listener):
            if hasattr(listener, "enterRos_file_input"):
                listener.enterRos_file_input(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitRos_file_input"):
                listener.exitRos_file_input(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitRos_file_input"):
                return visitor.visitRos_file_input(self)
            else:
                return visitor.visitChildren(self)




    def ros_file_input(self):

        localctx = RosMessageParser.Ros_file_inputContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_ros_file_input)
        try:
            self.state = 55
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 52
                self.ros_message_input()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 53
                self.ros_action_input()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 54
                self.ros_service_input()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ros_message_inputContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(RosMessageParser.Ros_message_inputContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ros_message(self):
            return self.getTypedRuleContext(RosMessageParser.Ros_messageContext,0)


        def EOF(self):
            return self.getToken(RosMessageParser.EOF, 0)

        def getRuleIndex(self):
            return RosMessageParser.RULE_ros_message_input

        def enterRule(self, listener):
            if hasattr(listener, "enterRos_message_input"):
                listener.enterRos_message_input(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitRos_message_input"):
                listener.exitRos_message_input(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitRos_message_input"):
                return visitor.visitRos_message_input(self)
            else:
                return visitor.visitChildren(self)




    def ros_message_input(self):

        localctx = RosMessageParser.Ros_message_inputContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_ros_message_input)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 57
            self.ros_message()
            self.state = 58
            self.match(RosMessageParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ros_action_inputContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(RosMessageParser.Ros_action_inputContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ros_message(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(RosMessageParser.Ros_messageContext)
            else:
                return self.getTypedRuleContext(RosMessageParser.Ros_messageContext,i)


        def MESSAGE_SEPARATOR(self, i=None):
            if i is None:
                return self.getTokens(RosMessageParser.MESSAGE_SEPARATOR)
            else:
                return self.getToken(RosMessageParser.MESSAGE_SEPARATOR, i)

        def EOF(self):
            return self.getToken(RosMessageParser.EOF, 0)

        def getRuleIndex(self):
            return RosMessageParser.RULE_ros_action_input

        def enterRule(self, listener):
            if hasattr(listener, "enterRos_action_input"):
                listener.enterRos_action_input(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitRos_action_input"):
                listener.exitRos_action_input(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitRos_action_input"):
                return visitor.visitRos_action_input(self)
            else:
                return visitor.visitChildren(self)




    def ros_action_input(self):

        localctx = RosMessageParser.Ros_action_inputContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_ros_action_input)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 60
            self.ros_message()
            self.state = 61
            self.match(RosMessageParser.MESSAGE_SEPARATOR)
            self.state = 62
            self.ros_message()
            self.state = 63
            self.match(RosMessageParser.MESSAGE_SEPARATOR)
            self.state = 64
            self.ros_message()
            self.state = 65
            self.match(RosMessageParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ros_service_inputContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(RosMessageParser.Ros_service_inputContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ros_message(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(RosMessageParser.Ros_messageContext)
            else:
                return self.getTypedRuleContext(RosMessageParser.Ros_messageContext,i)


        def MESSAGE_SEPARATOR(self):
            return self.getToken(RosMessageParser.MESSAGE_SEPARATOR, 0)

        def EOF(self):
            return self.getToken(RosMessageParser.EOF, 0)

        def getRuleIndex(self):
            return RosMessageParser.RULE_ros_service_input

        def enterRule(self, listener):
            if hasattr(listener, "enterRos_service_input"):
                listener.enterRos_service_input(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitRos_service_input"):
                listener.exitRos_service_input(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitRos_service_input"):
                return visitor.visitRos_service_input(self)
            else:
                return visitor.visitChildren(self)




    def ros_service_input(self):

        localctx = RosMessageParser.Ros_service_inputContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_ros_service_input)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 67
            self.ros_message()
            self.state = 68
            self.match(RosMessageParser.MESSAGE_SEPARATOR)
            self.state = 69
            self.ros_message()
            self.state = 70
            self.match(RosMessageParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Rosbag_inputContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(RosMessageParser.Rosbag_inputContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ros_message(self):
            return self.getTypedRuleContext(RosMessageParser.Ros_messageContext,0)


        def EOF(self):
            return self.getToken(RosMessageParser.EOF, 0)

        def rosbag_nested_message(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(RosMessageParser.Rosbag_nested_messageContext)
            else:
                return self.getTypedRuleContext(RosMessageParser.Rosbag_nested_messageContext,i)


        def getRuleIndex(self):
            return RosMessageParser.RULE_rosbag_input

        def enterRule(self, listener):
            if hasattr(listener, "enterRosbag_input"):
                listener.enterRosbag_input(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitRosbag_input"):
                listener.exitRosbag_input(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitRosbag_input"):
                return visitor.visitRosbag_input(self)
            else:
                return visitor.visitChildren(self)




    def rosbag_input(self):

        localctx = RosMessageParser.Rosbag_inputContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_rosbag_input)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 72
            self.ros_message()
            self.state = 76
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==RosMessageParser.ROSBAG_MESSAGE_SEPARATOR:
                self.state = 73
                self.rosbag_nested_message()
                self.state = 78
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 79
            self.match(RosMessageParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Rosbag_nested_messageContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(RosMessageParser.Rosbag_nested_messageContext, self).__init__(parent, invokingState)
            self.parser = parser

        def ROSBAG_MESSAGE_SEPARATOR(self):
            return self.getToken(RosMessageParser.ROSBAG_MESSAGE_SEPARATOR, 0)

        def ros_type(self):
            return self.getTypedRuleContext(RosMessageParser.Ros_typeContext,0)


        def ros_message(self):
            return self.getTypedRuleContext(RosMessageParser.Ros_messageContext,0)


        def getRuleIndex(self):
            return RosMessageParser.RULE_rosbag_nested_message

        def enterRule(self, listener):
            if hasattr(listener, "enterRosbag_nested_message"):
                listener.enterRosbag_nested_message(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitRosbag_nested_message"):
                listener.exitRosbag_nested_message(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitRosbag_nested_message"):
                return visitor.visitRosbag_nested_message(self)
            else:
                return visitor.visitChildren(self)




    def rosbag_nested_message(self):

        localctx = RosMessageParser.Rosbag_nested_messageContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_rosbag_nested_message)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 81
            self.match(RosMessageParser.ROSBAG_MESSAGE_SEPARATOR)
            self.state = 82
            self.ros_type()
            self.state = 83
            self.ros_message()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ros_messageContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(RosMessageParser.Ros_messageContext, self).__init__(parent, invokingState)
            self.parser = parser

        def field_declaration(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(RosMessageParser.Field_declarationContext)
            else:
                return self.getTypedRuleContext(RosMessageParser.Field_declarationContext,i)


        def constant_declaration(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(RosMessageParser.Constant_declarationContext)
            else:
                return self.getTypedRuleContext(RosMessageParser.Constant_declarationContext,i)


        def comment(self, i=None):
            if i is None:
                return self.getTypedRuleContexts(RosMessageParser.CommentContext)
            else:
                return self.getTypedRuleContext(RosMessageParser.CommentContext,i)


        def getRuleIndex(self):
            return RosMessageParser.RULE_ros_message

        def enterRule(self, listener):
            if hasattr(listener, "enterRos_message"):
                listener.enterRos_message(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitRos_message"):
                listener.exitRos_message(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitRos_message"):
                return visitor.visitRos_message(self)
            else:
                return visitor.visitChildren(self)




    def ros_message(self):

        localctx = RosMessageParser.Ros_messageContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_ros_message)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 90
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << RosMessageParser.BOOL) | (1 << RosMessageParser.INT8) | (1 << RosMessageParser.UINT8) | (1 << RosMessageParser.BYTE) | (1 << RosMessageParser.CHAR) | (1 << RosMessageParser.INT16) | (1 << RosMessageParser.UINT16) | (1 << RosMessageParser.INT32) | (1 << RosMessageParser.UINT32) | (1 << RosMessageParser.INT64) | (1 << RosMessageParser.UINT64) | (1 << RosMessageParser.FLOAT32) | (1 << RosMessageParser.FLOAT64) | (1 << RosMessageParser.STRING) | (1 << RosMessageParser.TIME) | (1 << RosMessageParser.DURATION) | (1 << RosMessageParser.HASH) | (1 << RosMessageParser.IDENTIFIER) | (1 << RosMessageParser.STRING_HASH))) != 0):
                self.state = 88
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,2,self._ctx)
                if la_ == 1:
                    self.state = 85
                    self.field_declaration()
                    pass

                elif la_ == 2:
                    self.state = 86
                    self.constant_declaration()
                    pass

                elif la_ == 3:
                    self.state = 87
                    self.comment()
                    pass


                self.state = 92
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Field_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(RosMessageParser.Field_declarationContext, self).__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(RosMessageParser.IdentifierContext,0)


        def dtype(self):
            return self.getTypedRuleContext(RosMessageParser.DtypeContext,0)


        def array_type(self):
            return self.getTypedRuleContext(RosMessageParser.Array_typeContext,0)


        def getRuleIndex(self):
            return RosMessageParser.RULE_field_declaration

        def enterRule(self, listener):
            if hasattr(listener, "enterField_declaration"):
                listener.enterField_declaration(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitField_declaration"):
                listener.exitField_declaration(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitField_declaration"):
                return visitor.visitField_declaration(self)
            else:
                return visitor.visitChildren(self)




    def field_declaration(self):

        localctx = RosMessageParser.Field_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_field_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 95
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
            if la_ == 1:
                self.state = 93
                self.dtype()
                pass

            elif la_ == 2:
                self.state = 94
                self.array_type()
                pass


            self.state = 97
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Constant_declarationContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(RosMessageParser.Constant_declarationContext, self).__init__(parent, invokingState)
            self.parser = parser

        def integral_type(self):
            return self.getTypedRuleContext(RosMessageParser.Integral_typeContext,0)


        def identifier(self):
            return self.getTypedRuleContext(RosMessageParser.IdentifierContext,0)


        def ASSIGNMENT(self):
            return self.getToken(RosMessageParser.ASSIGNMENT, 0)

        def integral_value(self):
            return self.getTypedRuleContext(RosMessageParser.Integral_valueContext,0)


        def floating_point_type(self):
            return self.getTypedRuleContext(RosMessageParser.Floating_point_typeContext,0)


        def floating_point_value(self):
            return self.getTypedRuleContext(RosMessageParser.Floating_point_valueContext,0)


        def boolean_type(self):
            return self.getTypedRuleContext(RosMessageParser.Boolean_typeContext,0)


        def bool_value(self):
            return self.getTypedRuleContext(RosMessageParser.Bool_valueContext,0)


        def string_type(self):
            return self.getTypedRuleContext(RosMessageParser.String_typeContext,0)


        def STRING_ASSIGNMENT(self):
            return self.getToken(RosMessageParser.STRING_ASSIGNMENT, 0)

        def string_value(self):
            return self.getTypedRuleContext(RosMessageParser.String_valueContext,0)


        def getRuleIndex(self):
            return RosMessageParser.RULE_constant_declaration

        def enterRule(self, listener):
            if hasattr(listener, "enterConstant_declaration"):
                listener.enterConstant_declaration(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitConstant_declaration"):
                listener.exitConstant_declaration(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitConstant_declaration"):
                return visitor.visitConstant_declaration(self)
            else:
                return visitor.visitChildren(self)




    def constant_declaration(self):

        localctx = RosMessageParser.Constant_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_constant_declaration)
        try:
            self.state = 123
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [RosMessageParser.INT8, RosMessageParser.UINT8, RosMessageParser.BYTE, RosMessageParser.CHAR, RosMessageParser.INT16, RosMessageParser.UINT16, RosMessageParser.INT32, RosMessageParser.UINT32, RosMessageParser.INT64, RosMessageParser.UINT64]:
                self.enterOuterAlt(localctx, 1)
                self.state = 99
                self.integral_type()
                self.state = 100
                self.identifier()
                self.state = 101
                self.match(RosMessageParser.ASSIGNMENT)
                self.state = 102
                self.integral_value()
                pass
            elif token in [RosMessageParser.FLOAT32, RosMessageParser.FLOAT64]:
                self.enterOuterAlt(localctx, 2)
                self.state = 104
                self.floating_point_type()
                self.state = 105
                self.identifier()
                self.state = 106
                self.match(RosMessageParser.ASSIGNMENT)
                self.state = 109
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
                if la_ == 1:
                    self.state = 107
                    self.integral_value()
                    pass

                elif la_ == 2:
                    self.state = 108
                    self.floating_point_value()
                    pass


                pass
            elif token in [RosMessageParser.BOOL]:
                self.enterOuterAlt(localctx, 3)
                self.state = 111
                self.boolean_type()
                self.state = 112
                self.identifier()
                self.state = 113
                self.match(RosMessageParser.ASSIGNMENT)
                self.state = 116
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [RosMessageParser.TRUE, RosMessageParser.FALSE]:
                    self.state = 114
                    self.bool_value()
                    pass
                elif token in [RosMessageParser.PLUS, RosMessageParser.MINUS, RosMessageParser.INTEGER_LITERAL]:
                    self.state = 115
                    self.integral_value()
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            elif token in [RosMessageParser.STRING]:
                self.enterOuterAlt(localctx, 4)
                self.state = 118
                self.string_type()
                self.state = 119
                self.identifier()
                self.state = 120
                self.match(RosMessageParser.STRING_ASSIGNMENT)
                self.state = 121
                self.string_value()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CommentContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(RosMessageParser.CommentContext, self).__init__(parent, invokingState)
            self.parser = parser

        def COMMENT(self):
            return self.getToken(RosMessageParser.COMMENT, 0)

        def HASH(self):
            return self.getToken(RosMessageParser.HASH, 0)

        def STRING_HASH(self):
            return self.getToken(RosMessageParser.STRING_HASH, 0)

        def getRuleIndex(self):
            return RosMessageParser.RULE_comment

        def enterRule(self, listener):
            if hasattr(listener, "enterComment"):
                listener.enterComment(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitComment"):
                listener.exitComment(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitComment"):
                return visitor.visitComment(self)
            else:
                return visitor.visitChildren(self)




    def comment(self):

        localctx = RosMessageParser.CommentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_comment)
        self._la = 0 # Token type
        try:
            self.state = 128
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 125
                _la = self._input.LA(1)
                if not(_la==RosMessageParser.HASH or _la==RosMessageParser.STRING_HASH):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 126
                self.match(RosMessageParser.COMMENT)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 127
                _la = self._input.LA(1)
                if not(_la==RosMessageParser.HASH or _la==RosMessageParser.STRING_HASH):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(RosMessageParser.IdentifierContext, self).__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(RosMessageParser.IDENTIFIER, 0)

        def STRING_IDENTIFIER(self):
            return self.getToken(RosMessageParser.STRING_IDENTIFIER, 0)

        def INT8(self):
            return self.getToken(RosMessageParser.INT8, 0)

        def UINT8(self):
            return self.getToken(RosMessageParser.UINT8, 0)

        def INT16(self):
            return self.getToken(RosMessageParser.INT16, 0)

        def UINT16(self):
            return self.getToken(RosMessageParser.UINT16, 0)

        def INT32(self):
            return self.getToken(RosMessageParser.INT32, 0)

        def UINT32(self):
            return self.getToken(RosMessageParser.UINT32, 0)

        def INT64(self):
            return self.getToken(RosMessageParser.INT64, 0)

        def UINT64(self):
            return self.getToken(RosMessageParser.UINT64, 0)

        def BYTE(self):
            return self.getToken(RosMessageParser.BYTE, 0)

        def CHAR(self):
            return self.getToken(RosMessageParser.CHAR, 0)

        def FLOAT32(self):
            return self.getToken(RosMessageParser.FLOAT32, 0)

        def FLOAT64(self):
            return self.getToken(RosMessageParser.FLOAT64, 0)

        def TIME(self):
            return self.getToken(RosMessageParser.TIME, 0)

        def DURATION(self):
            return self.getToken(RosMessageParser.DURATION, 0)

        def STRING(self):
            return self.getToken(RosMessageParser.STRING, 0)

        def BOOL(self):
            return self.getToken(RosMessageParser.BOOL, 0)

        def TRUE(self):
            return self.getToken(RosMessageParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(RosMessageParser.FALSE, 0)

        def getRuleIndex(self):
            return RosMessageParser.RULE_identifier

        def enterRule(self, listener):
            if hasattr(listener, "enterIdentifier"):
                listener.enterIdentifier(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitIdentifier"):
                listener.exitIdentifier(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitIdentifier"):
                return visitor.visitIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def identifier(self):

        localctx = RosMessageParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_identifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 130
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << RosMessageParser.BOOL) | (1 << RosMessageParser.INT8) | (1 << RosMessageParser.UINT8) | (1 << RosMessageParser.BYTE) | (1 << RosMessageParser.CHAR) | (1 << RosMessageParser.INT16) | (1 << RosMessageParser.UINT16) | (1 << RosMessageParser.INT32) | (1 << RosMessageParser.UINT32) | (1 << RosMessageParser.INT64) | (1 << RosMessageParser.UINT64) | (1 << RosMessageParser.FLOAT32) | (1 << RosMessageParser.FLOAT64) | (1 << RosMessageParser.STRING) | (1 << RosMessageParser.TIME) | (1 << RosMessageParser.DURATION) | (1 << RosMessageParser.TRUE) | (1 << RosMessageParser.FALSE) | (1 << RosMessageParser.IDENTIFIER) | (1 << RosMessageParser.STRING_IDENTIFIER))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DtypeContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(RosMessageParser.DtypeContext, self).__init__(parent, invokingState)
            self.parser = parser

        def integral_type(self):
            return self.getTypedRuleContext(RosMessageParser.Integral_typeContext,0)


        def floating_point_type(self):
            return self.getTypedRuleContext(RosMessageParser.Floating_point_typeContext,0)


        def temportal_type(self):
            return self.getTypedRuleContext(RosMessageParser.Temportal_typeContext,0)


        def boolean_type(self):
            return self.getTypedRuleContext(RosMessageParser.Boolean_typeContext,0)


        def string_type(self):
            return self.getTypedRuleContext(RosMessageParser.String_typeContext,0)


        def ros_type(self):
            return self.getTypedRuleContext(RosMessageParser.Ros_typeContext,0)


        def getRuleIndex(self):
            return RosMessageParser.RULE_dtype

        def enterRule(self, listener):
            if hasattr(listener, "enterDtype"):
                listener.enterDtype(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitDtype"):
                listener.exitDtype(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitDtype"):
                return visitor.visitDtype(self)
            else:
                return visitor.visitChildren(self)




    def dtype(self):

        localctx = RosMessageParser.DtypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_dtype)
        try:
            self.state = 138
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [RosMessageParser.INT8, RosMessageParser.UINT8, RosMessageParser.BYTE, RosMessageParser.CHAR, RosMessageParser.INT16, RosMessageParser.UINT16, RosMessageParser.INT32, RosMessageParser.UINT32, RosMessageParser.INT64, RosMessageParser.UINT64]:
                self.enterOuterAlt(localctx, 1)
                self.state = 132
                self.integral_type()
                pass
            elif token in [RosMessageParser.FLOAT32, RosMessageParser.FLOAT64]:
                self.enterOuterAlt(localctx, 2)
                self.state = 133
                self.floating_point_type()
                pass
            elif token in [RosMessageParser.TIME, RosMessageParser.DURATION]:
                self.enterOuterAlt(localctx, 3)
                self.state = 134
                self.temportal_type()
                pass
            elif token in [RosMessageParser.BOOL]:
                self.enterOuterAlt(localctx, 4)
                self.state = 135
                self.boolean_type()
                pass
            elif token in [RosMessageParser.STRING]:
                self.enterOuterAlt(localctx, 5)
                self.state = 136
                self.string_type()
                pass
            elif token in [RosMessageParser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 6)
                self.state = 137
                self.ros_type()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ros_typeContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(RosMessageParser.Ros_typeContext, self).__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self, i=None):
            if i is None:
                return self.getTokens(RosMessageParser.IDENTIFIER)
            else:
                return self.getToken(RosMessageParser.IDENTIFIER, i)

        def SLASH(self):
            return self.getToken(RosMessageParser.SLASH, 0)

        def getRuleIndex(self):
            return RosMessageParser.RULE_ros_type

        def enterRule(self, listener):
            if hasattr(listener, "enterRos_type"):
                listener.enterRos_type(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitRos_type"):
                listener.exitRos_type(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitRos_type"):
                return visitor.visitRos_type(self)
            else:
                return visitor.visitChildren(self)




    def ros_type(self):

        localctx = RosMessageParser.Ros_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_ros_type)
        try:
            self.state = 144
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,10,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 140
                self.match(RosMessageParser.IDENTIFIER)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 141
                self.match(RosMessageParser.IDENTIFIER)
                self.state = 142
                self.match(RosMessageParser.SLASH)
                self.state = 143
                self.match(RosMessageParser.IDENTIFIER)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Array_typeContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(RosMessageParser.Array_typeContext, self).__init__(parent, invokingState)
            self.parser = parser

        def variable_array_type(self):
            return self.getTypedRuleContext(RosMessageParser.Variable_array_typeContext,0)


        def fixed_array_type(self):
            return self.getTypedRuleContext(RosMessageParser.Fixed_array_typeContext,0)


        def getRuleIndex(self):
            return RosMessageParser.RULE_array_type

        def enterRule(self, listener):
            if hasattr(listener, "enterArray_type"):
                listener.enterArray_type(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitArray_type"):
                listener.exitArray_type(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitArray_type"):
                return visitor.visitArray_type(self)
            else:
                return visitor.visitChildren(self)




    def array_type(self):

        localctx = RosMessageParser.Array_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_array_type)
        try:
            self.state = 148
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 146
                self.variable_array_type()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 147
                self.fixed_array_type()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Variable_array_typeContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(RosMessageParser.Variable_array_typeContext, self).__init__(parent, invokingState)
            self.parser = parser

        def dtype(self):
            return self.getTypedRuleContext(RosMessageParser.DtypeContext,0)


        def OPEN_BRACKET(self):
            return self.getToken(RosMessageParser.OPEN_BRACKET, 0)

        def STRING_OPEN_BRACKET(self):
            return self.getToken(RosMessageParser.STRING_OPEN_BRACKET, 0)

        def CLOSE_BRACKET(self):
            return self.getToken(RosMessageParser.CLOSE_BRACKET, 0)

        def STRING_CLOSE_BRACKET(self):
            return self.getToken(RosMessageParser.STRING_CLOSE_BRACKET, 0)

        def getRuleIndex(self):
            return RosMessageParser.RULE_variable_array_type

        def enterRule(self, listener):
            if hasattr(listener, "enterVariable_array_type"):
                listener.enterVariable_array_type(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitVariable_array_type"):
                listener.exitVariable_array_type(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitVariable_array_type"):
                return visitor.visitVariable_array_type(self)
            else:
                return visitor.visitChildren(self)




    def variable_array_type(self):

        localctx = RosMessageParser.Variable_array_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_variable_array_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 150
            self.dtype()
            self.state = 151
            _la = self._input.LA(1)
            if not(_la==RosMessageParser.OPEN_BRACKET or _la==RosMessageParser.STRING_OPEN_BRACKET):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 152
            _la = self._input.LA(1)
            if not(_la==RosMessageParser.CLOSE_BRACKET or _la==RosMessageParser.STRING_CLOSE_BRACKET):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fixed_array_typeContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(RosMessageParser.Fixed_array_typeContext, self).__init__(parent, invokingState)
            self.parser = parser

        def dtype(self):
            return self.getTypedRuleContext(RosMessageParser.DtypeContext,0)


        def OPEN_BRACKET(self):
            return self.getToken(RosMessageParser.OPEN_BRACKET, 0)

        def INTEGER_LITERAL(self):
            return self.getToken(RosMessageParser.INTEGER_LITERAL, 0)

        def CLOSE_BRACKET(self):
            return self.getToken(RosMessageParser.CLOSE_BRACKET, 0)

        def STRING_OPEN_BRACKET(self):
            return self.getToken(RosMessageParser.STRING_OPEN_BRACKET, 0)

        def STRING_INTEGER_LITERAL(self):
            return self.getToken(RosMessageParser.STRING_INTEGER_LITERAL, 0)

        def STRING_CLOSE_BRACKET(self):
            return self.getToken(RosMessageParser.STRING_CLOSE_BRACKET, 0)

        def getRuleIndex(self):
            return RosMessageParser.RULE_fixed_array_type

        def enterRule(self, listener):
            if hasattr(listener, "enterFixed_array_type"):
                listener.enterFixed_array_type(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitFixed_array_type"):
                listener.exitFixed_array_type(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitFixed_array_type"):
                return visitor.visitFixed_array_type(self)
            else:
                return visitor.visitChildren(self)




    def fixed_array_type(self):

        localctx = RosMessageParser.Fixed_array_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_fixed_array_type)
        try:
            self.state = 164
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 154
                self.dtype()
                self.state = 155
                self.match(RosMessageParser.OPEN_BRACKET)
                self.state = 156
                self.match(RosMessageParser.INTEGER_LITERAL)
                self.state = 157
                self.match(RosMessageParser.CLOSE_BRACKET)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 159
                self.dtype()
                self.state = 160
                self.match(RosMessageParser.STRING_OPEN_BRACKET)
                self.state = 161
                self.match(RosMessageParser.STRING_INTEGER_LITERAL)
                self.state = 162
                self.match(RosMessageParser.STRING_CLOSE_BRACKET)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Integral_typeContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(RosMessageParser.Integral_typeContext, self).__init__(parent, invokingState)
            self.parser = parser

        def INT8(self):
            return self.getToken(RosMessageParser.INT8, 0)

        def UINT8(self):
            return self.getToken(RosMessageParser.UINT8, 0)

        def INT16(self):
            return self.getToken(RosMessageParser.INT16, 0)

        def UINT16(self):
            return self.getToken(RosMessageParser.UINT16, 0)

        def INT32(self):
            return self.getToken(RosMessageParser.INT32, 0)

        def UINT32(self):
            return self.getToken(RosMessageParser.UINT32, 0)

        def INT64(self):
            return self.getToken(RosMessageParser.INT64, 0)

        def UINT64(self):
            return self.getToken(RosMessageParser.UINT64, 0)

        def BYTE(self):
            return self.getToken(RosMessageParser.BYTE, 0)

        def CHAR(self):
            return self.getToken(RosMessageParser.CHAR, 0)

        def getRuleIndex(self):
            return RosMessageParser.RULE_integral_type

        def enterRule(self, listener):
            if hasattr(listener, "enterIntegral_type"):
                listener.enterIntegral_type(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitIntegral_type"):
                listener.exitIntegral_type(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitIntegral_type"):
                return visitor.visitIntegral_type(self)
            else:
                return visitor.visitChildren(self)




    def integral_type(self):

        localctx = RosMessageParser.Integral_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_integral_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 166
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << RosMessageParser.INT8) | (1 << RosMessageParser.UINT8) | (1 << RosMessageParser.BYTE) | (1 << RosMessageParser.CHAR) | (1 << RosMessageParser.INT16) | (1 << RosMessageParser.UINT16) | (1 << RosMessageParser.INT32) | (1 << RosMessageParser.UINT32) | (1 << RosMessageParser.INT64) | (1 << RosMessageParser.UINT64))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Floating_point_typeContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(RosMessageParser.Floating_point_typeContext, self).__init__(parent, invokingState)
            self.parser = parser

        def FLOAT32(self):
            return self.getToken(RosMessageParser.FLOAT32, 0)

        def FLOAT64(self):
            return self.getToken(RosMessageParser.FLOAT64, 0)

        def getRuleIndex(self):
            return RosMessageParser.RULE_floating_point_type

        def enterRule(self, listener):
            if hasattr(listener, "enterFloating_point_type"):
                listener.enterFloating_point_type(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitFloating_point_type"):
                listener.exitFloating_point_type(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitFloating_point_type"):
                return visitor.visitFloating_point_type(self)
            else:
                return visitor.visitChildren(self)




    def floating_point_type(self):

        localctx = RosMessageParser.Floating_point_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_floating_point_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 168
            _la = self._input.LA(1)
            if not(_la==RosMessageParser.FLOAT32 or _la==RosMessageParser.FLOAT64):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Temportal_typeContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(RosMessageParser.Temportal_typeContext, self).__init__(parent, invokingState)
            self.parser = parser

        def TIME(self):
            return self.getToken(RosMessageParser.TIME, 0)

        def DURATION(self):
            return self.getToken(RosMessageParser.DURATION, 0)

        def getRuleIndex(self):
            return RosMessageParser.RULE_temportal_type

        def enterRule(self, listener):
            if hasattr(listener, "enterTemportal_type"):
                listener.enterTemportal_type(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitTemportal_type"):
                listener.exitTemportal_type(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitTemportal_type"):
                return visitor.visitTemportal_type(self)
            else:
                return visitor.visitChildren(self)




    def temportal_type(self):

        localctx = RosMessageParser.Temportal_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_temportal_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 170
            _la = self._input.LA(1)
            if not(_la==RosMessageParser.TIME or _la==RosMessageParser.DURATION):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class String_typeContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(RosMessageParser.String_typeContext, self).__init__(parent, invokingState)
            self.parser = parser

        def STRING(self):
            return self.getToken(RosMessageParser.STRING, 0)

        def getRuleIndex(self):
            return RosMessageParser.RULE_string_type

        def enterRule(self, listener):
            if hasattr(listener, "enterString_type"):
                listener.enterString_type(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitString_type"):
                listener.exitString_type(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitString_type"):
                return visitor.visitString_type(self)
            else:
                return visitor.visitChildren(self)




    def string_type(self):

        localctx = RosMessageParser.String_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_string_type)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 172
            self.match(RosMessageParser.STRING)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Boolean_typeContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(RosMessageParser.Boolean_typeContext, self).__init__(parent, invokingState)
            self.parser = parser

        def BOOL(self):
            return self.getToken(RosMessageParser.BOOL, 0)

        def getRuleIndex(self):
            return RosMessageParser.RULE_boolean_type

        def enterRule(self, listener):
            if hasattr(listener, "enterBoolean_type"):
                listener.enterBoolean_type(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitBoolean_type"):
                listener.exitBoolean_type(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitBoolean_type"):
                return visitor.visitBoolean_type(self)
            else:
                return visitor.visitChildren(self)




    def boolean_type(self):

        localctx = RosMessageParser.Boolean_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_boolean_type)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 174
            self.match(RosMessageParser.BOOL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SignContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(RosMessageParser.SignContext, self).__init__(parent, invokingState)
            self.parser = parser

        def PLUS(self):
            return self.getToken(RosMessageParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(RosMessageParser.MINUS, 0)

        def getRuleIndex(self):
            return RosMessageParser.RULE_sign

        def enterRule(self, listener):
            if hasattr(listener, "enterSign"):
                listener.enterSign(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitSign"):
                listener.exitSign(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitSign"):
                return visitor.visitSign(self)
            else:
                return visitor.visitChildren(self)




    def sign(self):

        localctx = RosMessageParser.SignContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_sign)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 176
            _la = self._input.LA(1)
            if not(_la==RosMessageParser.PLUS or _la==RosMessageParser.MINUS):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Integral_valueContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(RosMessageParser.Integral_valueContext, self).__init__(parent, invokingState)
            self.parser = parser

        def INTEGER_LITERAL(self):
            return self.getToken(RosMessageParser.INTEGER_LITERAL, 0)

        def sign(self):
            return self.getTypedRuleContext(RosMessageParser.SignContext,0)


        def getRuleIndex(self):
            return RosMessageParser.RULE_integral_value

        def enterRule(self, listener):
            if hasattr(listener, "enterIntegral_value"):
                listener.enterIntegral_value(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitIntegral_value"):
                listener.exitIntegral_value(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitIntegral_value"):
                return visitor.visitIntegral_value(self)
            else:
                return visitor.visitChildren(self)




    def integral_value(self):

        localctx = RosMessageParser.Integral_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_integral_value)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 179
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==RosMessageParser.PLUS or _la==RosMessageParser.MINUS:
                self.state = 178
                self.sign()


            self.state = 181
            self.match(RosMessageParser.INTEGER_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Floating_point_valueContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(RosMessageParser.Floating_point_valueContext, self).__init__(parent, invokingState)
            self.parser = parser

        def REAL_LITERAL(self):
            return self.getToken(RosMessageParser.REAL_LITERAL, 0)

        def sign(self):
            return self.getTypedRuleContext(RosMessageParser.SignContext,0)


        def getRuleIndex(self):
            return RosMessageParser.RULE_floating_point_value

        def enterRule(self, listener):
            if hasattr(listener, "enterFloating_point_value"):
                listener.enterFloating_point_value(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitFloating_point_value"):
                listener.exitFloating_point_value(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitFloating_point_value"):
                return visitor.visitFloating_point_value(self)
            else:
                return visitor.visitChildren(self)




    def floating_point_value(self):

        localctx = RosMessageParser.Floating_point_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_floating_point_value)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 184
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==RosMessageParser.PLUS or _la==RosMessageParser.MINUS:
                self.state = 183
                self.sign()


            self.state = 186
            self.match(RosMessageParser.REAL_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Bool_valueContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(RosMessageParser.Bool_valueContext, self).__init__(parent, invokingState)
            self.parser = parser

        def TRUE(self):
            return self.getToken(RosMessageParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(RosMessageParser.FALSE, 0)

        def getRuleIndex(self):
            return RosMessageParser.RULE_bool_value

        def enterRule(self, listener):
            if hasattr(listener, "enterBool_value"):
                listener.enterBool_value(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitBool_value"):
                listener.exitBool_value(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitBool_value"):
                return visitor.visitBool_value(self)
            else:
                return visitor.visitChildren(self)




    def bool_value(self):

        localctx = RosMessageParser.Bool_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_bool_value)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 188
            _la = self._input.LA(1)
            if not(_la==RosMessageParser.TRUE or _la==RosMessageParser.FALSE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class String_valueContext(ParserRuleContext):

        def __init__(self, parser, parent=None, invokingState=-1):
            super(RosMessageParser.String_valueContext, self).__init__(parent, invokingState)
            self.parser = parser

        def STRING_VALUE(self):
            return self.getToken(RosMessageParser.STRING_VALUE, 0)

        def getRuleIndex(self):
            return RosMessageParser.RULE_string_value

        def enterRule(self, listener):
            if hasattr(listener, "enterString_value"):
                listener.enterString_value(self)

        def exitRule(self, listener):
            if hasattr(listener, "exitString_value"):
                listener.exitString_value(self)

        def accept(self, visitor):
            if hasattr(visitor, "visitString_value"):
                return visitor.visitString_value(self)
            else:
                return visitor.visitChildren(self)




    def string_value(self):

        localctx = RosMessageParser.String_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_string_value)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 190
            self.match(RosMessageParser.STRING_VALUE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





